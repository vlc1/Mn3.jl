### A Pluto.jl notebook ###
# v0.14.4

using Markdown
using InteractiveUtils

# ‚ïî‚ïê‚ï° 35a850c8-d24c-4593-b551-f3b9bb49e82d
begin
	using NLsolve
	solve(f!, x‚ÇÄ) = getproperty(nlsolve(f!, x‚ÇÄ), :zero)
end

# ‚ïî‚ïê‚ï° ec1b0cec-af5f-492e-ba55-269c2df5b458
using LinearAlgebra

# ‚ïî‚ïê‚ï° e8b460cf-3d35-4bbb-8b3a-5a2c5f8a7a21
using Plots

# ‚ïî‚ïê‚ï° d61e1ea6-f924-11ea-00dc-794c93177d22
md"""
Version [Pluto](https://github.com/vlc1/Mn3.jl/blob/master/notebook/tp/2/tp2.jl) de ce notebook.

"""

# ‚ïî‚ïê‚ï° 3e5d9fa5-acae-42ab-b40e-e1a197edcad2
md"""
# Programmation

Quelques points vont √™tre abord√©s en d√©but de s√©ance :

1. Deux nouveaux *packages* : `Plots` et `NLsolve` ;
1. Fonctions et types d'arguments ;
1. La notation `.` (*broadcast) ;
1. Premier (`first`) et dernier (`last`) √©l√©ments d'un tableau.

"""

# ‚ïî‚ïê‚ï° 4ae18622-f7ec-11ea-2f71-d5b166ff50fb
md"""
# Recherche de la racine d'une fonction

Nous avons vu lors de la deuxi√®me s√©ance que les √©l√©ments
```math
\begin{aligned}
y_1 & \simeq y \left ( t_1 \right ), \\
y_2 & \simeq y \left ( t_2 \right ), \\
& \ldots
\end{aligned}
```
de la solution num√©rique du probl√®me de Cauchy
```math
\left \{ \begin{aligned}
\dot{y} \left ( t \right ) & = f \left [ t, y \left ( t \right ) \right ], \\
y \left ( 0 \right ) & = y_0
\end{aligned} \right .
```
sont d√©finis implicitement, c'est √† dire comme racines de fonctions.

L'objectif de cette premi√®re partie est de se familiariser avec le *package* `NLsolve.jl` que nous utiliserons afin de r√©soudre des √©quations non-lin√©aires.

Les cellules suivantes d√©crivent comment obtenir la racine de la function
```math
\left ( \begin{matrix}
x \\
y \end{matrix} \right ) \mapsto \left ( \begin{matrix}
\left ( x + 3 \right ) \left ( y ^ 3 - 7 \right ) + 18 \\
\sin \left [ y \exp \left ( x \right ) - 1 \right ]
\end{matrix} \right )
```
√† partir de la donn√©e initiale
```math
\left ( x_0, y_0 \right ) = \left ( 0.1, 1.2 \right ).
```

"""

# ‚ïî‚ïê‚ï° 88dd8a5e-651a-4939-9231-6696b78f024c
function example!(res, x)
    res[1] = (x[1] + 3) * (x[2] ^ 3 - 7) + 18
    res[2] = sin(x[2] * exp(x[1]) - 1)
	nothing
end

# ‚ïî‚ïê‚ï° 7dccedba-aa05-4821-b1ed-ed873ad9cccb
solve(example!, [0.1; 1.2])

# ‚ïî‚ïê‚ï° 073d29d8-7055-4d0c-8565-8732017b89d0
md"""
1. **Cas scalaire** -- Modifier l'exemple pr√©c√©dent afin de r√©soudre l'√©quation de Kepler
```math
10 - x + e \sin \left ( x \right ) = 0.
```
On d√©finira dans un premier temps la fonction `kepler!` d√©finie ci-dessous.

"""

# ‚ïî‚ïê‚ï° bea20ce9-88ff-45e4-bb5a-494c4d2d19c2
# Q1 -- √Ä MODIFIER
function kepler!(res, x)
	res[1] = x[1] - 1
	nothing
end

# ‚ïî‚ïê‚ï° 2c4151ac-a476-4c1f-a379-f4c3a0174b3d
if norm(solve(kepler!, [0.0]) - [5.08912]) ‚â§ 1e-4
	md"""
	!!! tip "üòÉ Bonne r√©ponse"

		Votre impl√©mentation de `kepler!` est correcte.
	"""
else
	md"""
	!!! danger "üò° Mauvaise r√©ponse"

		V√©rifier votre impl√©mentation de `kepler!`.
	"""
end

# ‚ïî‚ïê‚ï° b72fd704-46f9-4d88-86bd-7add43c47d0e
md"""
2. **Cas vectoriel** -- Modifier la fonction `system!` ci-dessous afin de r√©soudre le syst√®me d'√©quations
```math
\left \{ \begin{aligned}
x + y + z ^ 2 & = 12, \\
x ^ 2 - y + z & = 2, \\
2x - y ^ 2 + z & = 1.
\end{aligned} \right .
```

"""

# ‚ïî‚ïê‚ï° d264f45c-7a66-48d5-b6c3-b297073f5ce8
# Q2 -- √Ä MODIFIER
function system!(res, x)
	res[1] = x[1] + 1
	res[2] = x[2] + 2
	res[3] = x[3] + 3
	nothing
end

# ‚ïî‚ïê‚ï° 42e83fa4-ba23-4e80-a8e6-58816319b134
if norm(solve(system!, [0.0; 0.0; 0.0]) - [1.0; 2.0; 3.0]) ‚â§ 1e-4
	md"""
	!!! tip "üòÉ Bonne r√©ponse"

		Votre impl√©mentation de `system!` est correcte.
	"""
else
	md"""
	!!! danger "üò° Mauvaise r√©ponse"

		V√©rifier votre impl√©mentation de `system!`.
	"""
end

# ‚ïî‚ïê‚ï° 7dc345ee-f7ec-11ea-138f-a1c6b81e0260
md"""
# Mod√®le et solution exacte

On se concentre pour l'instant sur le mod√®le lin√©aire homog√®ne pour lequel le second membre de l'EDO s'√©crit
```math
f \colon \left ( t, y \right ) \mapsto \lambda y.
```

L'√©quation diff√©rentielle √† r√©soudre s'√©crit alors,
```math
\left \{ \begin{aligned}
\dot{y} \left ( t \right ) & = \lambda y \left ( t \right ), \\
y \left ( 0 \right ) & = y_0
\end{aligned} \right .
```
et la solution exacte est donn√©e sous la forme :
```math
y \colon t \mapsto \exp \left ( \lambda t \right ) y_0.
```

3. Impl√©menter la fonction ``f``, appel√©e ci-dessous `linear`, dans le cas ``\lambda = -1``.

"""

# ‚ïî‚ïê‚ï° 58162516-f7ec-11ea-3095-85bde6d71604
# Q3 -- √Ä MODIFIER
linear(t, y) = zero(y)

# ‚ïî‚ïê‚ï° dcf06721-1996-42ce-8c77-93f6f5195c7d
if norm(linear(nothing, [œÄ; 2 // 3]) + [œÄ; 2 // 3]) ‚â§ 1e-4
	md"""
	!!! tip "üòÉ Bonne r√©ponse"

		Votre impl√©mentation de `linear` est correcte.
	"""
else
	md"""
	!!! danger "üò° Mauvaise r√©ponse"

		V√©rifier votre impl√©mentation de `linear`.
	"""
end

# ‚ïî‚ïê‚ï° 56b5b3ec-7ec2-483c-8120-156665b2c49f
md"""
4. Impl√©menter la fonction `solution` qui correspond √† la solution analytique dans le cas ``\lambda = -1`` et ``y_0 = 1``.

"""

# ‚ïî‚ïê‚ï° 3ab81476-f7f8-11ea-3633-09930c9cdffe
# Q4 -- √Ä MODIFIER
solution(t, y = ones(1)) = y

# ‚ïî‚ïê‚ï° 2f1bd88d-9d9c-4fd6-aef5-5d061994759f
if norm(solution(1.0) - [0.36788]) ‚â§ 1e-4
	md"""
	!!! tip "üòÉ Bonne r√©ponse"

		Votre impl√©mentation de `solution` est correcte.
	"""
else
	md"""
	!!! danger "üò° Mauvaise r√©ponse"

		V√©rifier votre impl√©mentation de `solution`.
	"""
end

# ‚ïî‚ïê‚ï° 8a4674da-f7ec-11ea-2faf-4b332a41d7fc
md"""
# Sch√©ma num√©rique

On rappelle que lors du cours pr√©c√©dent, tois sch√©mas num√©riques ont √©t√© pr√©sent√©s, √† savoir :
```math
y_{n + 1} - y_n - \tau f \left ( t_n, y_n \right ) = 0 \quad \text{(Euler explicite)},
```
```math
y_{n + 1} - y_n - \tau f \left ( t_{n + 1}, y_{n + 1} \right ) = 0 \quad \text{(Euler implicite)},
```
et
```math
y_{n + 1} - y_n - \tau f \left ( \frac{t_n + t_{n + 1}}{2}, \frac{y_n + y_{n + 1}}{2} \right ) = 0 \quad \text{(point milieu)}.
```

5. En vous inspirant de l'impl√©mentation `explicit!` du sch√©ma explicite d'Euler pr√©sent√©e ci-dessous, impl√©menter les fonctions `implicit!` (a) et `midpoint!` (b) dont la racine est ``y_{n + 1}``. On pr√©servera le nombre et l'ordre des param√®tres, au nombre de 3, √† savoir

* `y` -- la solution pr√©c√©dente (``y _ n``) ;
* `œÑ` -- le pas de temps (``\tau``) ;
* `f` -- le mod√®le (``f``) ;
* `t` -- l'instant pr√©c√©dent, (``t _ n``).

"""

# ‚ïî‚ïê‚ï° 639dbbd7-e0eb-4234-a37a-254c6f751a74
function explicit!(res, x, y, œÑ, f, t)
	res .= x .- y .- œÑ .* f(t, y)
	nothing
end

# ‚ïî‚ïê‚ï° ba074cc6-64cb-4f0a-9996-e6306727663c
# Q5a -- √Ä MODIFIER
function implicit!(res, x, y, œÑ, f, t)
	res .= x .- y
	nothing
end

# ‚ïî‚ïê‚ï° ec517a8d-bdef-41e0-bb4e-fac9df1f3c24
# Q5b -- √Ä MODIFIER
function midpoint!(res, x, y, œÑ, f, t)
	res .= x .- y
	nothing
end

# ‚ïî‚ïê‚ï° c87b46c0-f7ec-11ea-2918-d306ffd1c2bd
md"""
# Int√©gration temporelle

Il reste √† pr√©sent √† assembler √† impl√©menter la bouche d'int√©gration temporelle. √âtant donn√©s

* Un mod√®le `f` ;
* Un pas de temps `œÑ` ;
* Et un instant `s`

la fonction `integrate` impl√©ment√©e ci-dessous retourne deux vecteurs, le premier contenant les instants
```math
t_0 \quad t_1 \quad \cdots \quad t_N = s
```
et le second la solution num√©rique, √† savoir
```math
y_0 \quad y_1 \quad \cdots \quad y_N.
```

"""

# ‚ïî‚ïê‚ï° 1887218b-4a77-4e76-8a97-54d90e69b419
function integrate(scheme!, f, œÑ, s)
	t, y = 0.0, ones(1)
    T, Y = [t], [y]

	while t < (1 - ‚àöeps(t)) * s

		y = solve(y) do res, x
			scheme!(res, x, y, œÑ, f, t)
		end
        t += œÑ

        push!(Y, y)
        push!(T, t)
	end

	T, Y
end

# ‚ïî‚ïê‚ï° a691aa87-e01d-40f6-84ae-29b9ab13fb2b
md"""
La solution num√©rique peut √™tre obtenue et visualis√©e comme suit.

"""

# ‚ïî‚ïê‚ï° b9a3b65e-9c81-499d-acc5-85afa8d6703b
begin
	local T, Y = integrate(explicit!, linear, 0.1, 1.0)
	local fig = plot()
	scatter!(fig, T, first.(Y), label = "num")
	plot!(fig, t -> first.(solution.(t)), label = "exact")
end

# ‚ïî‚ïê‚ï° 6be4f6f8-58e3-4e23-b34e-514e1045d08e
md"""
6. Utiliser les fonctions `linear` et `solution` d√©finie pr√©c√©demment dans l'impl√©mentation de la fonction `error` ci-dessous, qui calcule l'erreur
```math
y_N - y \left ( t_N \right )
```
en fonction du sch√©ma (`scheme!`) et du pas en temps (`œÑ`).

"""

# ‚ïî‚ïê‚ï° 7fafbd51-99a9-4fea-bebf-6160e62a3ef4
# Q6 -- √Ä MODIFIER
function error(scheme!, œÑ, s)
	T, Y = integrate(explicit!, linear, œÑ, s)
	norm(zero(Y))
end

# ‚ïî‚ïê‚ï° d764d914-7a16-434a-8954-1f7233ee601c
md"""
7. Calculer (en utilisant la fonction `error`) et reporter les erreurs √† l'instant `s = 1.0` dans le tableau ci-dessous. Commenter.

|             | `explicit!` | `implicit!` | `midpoint!` |
|:-----------:|:-----------:|:-----------:|:-----------:|
| `œÑ = 0.125` |             |             |             |
| `œÑ = 0.25`  |             |             |             |
| `œÑ = 0.5`   |             |             |             |
| `œÑ = 1.0`   |             |             |             |

8. On se place maintenant sur un horizon temporel plus long (`s = 10.0`). Augmenter la taille du pas de temps et commenter.

"""

# ‚ïî‚ïê‚ï° d4637d80-f8c1-11ea-1f7f-df462373ca2d
md"""

Tout l'int√©r√™t de l'utilisation du package `NLsolve.jl` est que notre impl√©mentation fonctionne pour les probl√®mes scalaires **non-lin√©aires**, ainsi que pour les cas **vectoriels**.

# Au del√† du cas lin√©aire

9. Utiliser ou imaginer un mod√®le scalaire non-lin√©aire en modifier la fonction `nonlinear` ci-dessous, et visualiser votre solution num√©rique pour chacun des trois sch√©mas sur le m√™me graphique. Vous pourrez par exemple utiliser la question 3 de l'exercice vu en TD :
```math
f \colon \left ( t, y \right ) \mapsto 2t - y ^ 2.
```

"""

# ‚ïî‚ïê‚ï° 91a712b2-f8bd-11ea-3b8c-1bfbd521d29a
# Q9 -- √Ä MODIFIER
nonlinear(t, y) = zero(y)

# ‚ïî‚ïê‚ï° 580e8356-4fd2-47e1-a5a4-7063998b4ecb
begin
	local T, Y = integrate(explicit!, nonlinear, 0.1, 1.0)
	local fig = plot()
	scatter!(fig, T, first.(Y), label = "num")
	plot!(fig, t -> first.(solution.(t)), label = "exact")
end

# ‚ïî‚ïê‚ï° 46222752-f91a-11ea-372e-2dde47c81add
md"""
# Au del√† du cas scalaire

On se propose de r√©soudre l'[√©quation de pr√©dation de Lotka-Volterra](https://fr.wikipedia.org/wiki/%C3%89quations_de_pr%C3%A9dation_de_Lotka-Volterra) :

> En math√©matiques, les √©quations de pr√©dation de Lotka-Volterra, que l'on d√©signe aussi sous le terme de "mod√®le proie-pr√©dateur", sont un couple d'√©quations diff√©rentielles non-lin√©aires du premier ordre, et sont couramment utilis√©es pour d√©crire la dynamique de syst√®mes biologiques dans lesquels un pr√©dateur et sa proie interagissent. Elles ont √©t√© propos√©es ind√©pendamment par Alfred James Lotka en 1925 et Vito Volterra en 1926.

Le syst√®me d'√©quations s'√©crit :
```math
\left \{ \begin{aligned}
\dot{x} \left ( t \right ) & = x \left ( t \right ) \left [ \alpha - \beta y \left ( t \right ) \right ], \\
\dot{y} \left ( t \right ) & = y \left ( t \right ) \left [ \delta x \left ( t \right ) - \gamma \right ]
\end{aligned} \right .
```
o√π

* ``t`` est le temps ;
* ``x \left ( t \right )`` est l'effectif des proies √† l'instant ``t`` ;
* ``y \left ( t \right )`` est l'effectif des pr√©dateurs √† l'instant ``t``.

Les param√®tres suivants enfin caract√©risent les interactions entre les deux esp√®ces :
```math
\alpha = 0.1, \quad \beta = 0.003, \quad \gamma = 0.06, \quad \delta = 0.0012.
```

10. Impl√©menter la fonction `lotka` correspond.
11. R√©soudre et visualiser les solutions num√©rique correspondant √† chacun des trois sch√©ma.

"""

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄd61e1ea6-f924-11ea-00dc-794c93177d22
# ‚ï†‚ïê35a850c8-d24c-4593-b551-f3b9bb49e82d
# ‚ï†‚ïêec1b0cec-af5f-492e-ba55-269c2df5b458
# ‚ï†‚ïêe8b460cf-3d35-4bbb-8b3a-5a2c5f8a7a21
# ‚ïü‚îÄ3e5d9fa5-acae-42ab-b40e-e1a197edcad2
# ‚ïü‚îÄ4ae18622-f7ec-11ea-2f71-d5b166ff50fb
# ‚ï†‚ïê88dd8a5e-651a-4939-9231-6696b78f024c
# ‚ï†‚ïê7dccedba-aa05-4821-b1ed-ed873ad9cccb
# ‚ïü‚îÄ073d29d8-7055-4d0c-8565-8732017b89d0
# ‚ï†‚ïêbea20ce9-88ff-45e4-bb5a-494c4d2d19c2
# ‚ïü‚îÄ2c4151ac-a476-4c1f-a379-f4c3a0174b3d
# ‚ïü‚îÄb72fd704-46f9-4d88-86bd-7add43c47d0e
# ‚ï†‚ïêd264f45c-7a66-48d5-b6c3-b297073f5ce8
# ‚ïü‚îÄ42e83fa4-ba23-4e80-a8e6-58816319b134
# ‚ïü‚îÄ7dc345ee-f7ec-11ea-138f-a1c6b81e0260
# ‚ï†‚ïê58162516-f7ec-11ea-3095-85bde6d71604
# ‚ïü‚îÄdcf06721-1996-42ce-8c77-93f6f5195c7d
# ‚ïü‚îÄ56b5b3ec-7ec2-483c-8120-156665b2c49f
# ‚ï†‚ïê3ab81476-f7f8-11ea-3633-09930c9cdffe
# ‚ïü‚îÄ2f1bd88d-9d9c-4fd6-aef5-5d061994759f
# ‚ïü‚îÄ8a4674da-f7ec-11ea-2faf-4b332a41d7fc
# ‚ï†‚ïê639dbbd7-e0eb-4234-a37a-254c6f751a74
# ‚ï†‚ïêba074cc6-64cb-4f0a-9996-e6306727663c
# ‚ï†‚ïêec517a8d-bdef-41e0-bb4e-fac9df1f3c24
# ‚ïü‚îÄc87b46c0-f7ec-11ea-2918-d306ffd1c2bd
# ‚ï†‚ïê1887218b-4a77-4e76-8a97-54d90e69b419
# ‚ïü‚îÄa691aa87-e01d-40f6-84ae-29b9ab13fb2b
# ‚ï†‚ïêb9a3b65e-9c81-499d-acc5-85afa8d6703b
# ‚ïü‚îÄ6be4f6f8-58e3-4e23-b34e-514e1045d08e
# ‚ï†‚ïê7fafbd51-99a9-4fea-bebf-6160e62a3ef4
# ‚ïü‚îÄd764d914-7a16-434a-8954-1f7233ee601c
# ‚ïü‚îÄd4637d80-f8c1-11ea-1f7f-df462373ca2d
# ‚ï†‚ïê91a712b2-f8bd-11ea-3b8c-1bfbd521d29a
# ‚ï†‚ïê580e8356-4fd2-47e1-a5a4-7063998b4ecb
# ‚ïü‚îÄ46222752-f91a-11ea-372e-2dde47c81add
